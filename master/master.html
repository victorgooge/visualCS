<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visual.CS</title>
  <link rel="icon" href="../images/icon.png">
</head>
<style>
    body {
        font-family: Arial, sans-serif;
        text-align: center;
        margin: 0;
        padding: 0;
    }

    .container {
        margin-top: 50px;
        height: 800px;
        background-color: #f8f8f8;
        border: 1px solid #ccc;
    }

    .tree {
        position: relative;
        top: 50px;
        width: 100%;
    }

    .node {
        width: 50px;
        height: 50px;
        background-color: white;
        border: 6px solid black;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        font-weight: bold;
        position: absolute;
        transition: background-color 0.5s ease;
    }

    .node.visited {
        background-color: rgb(122, 180, 255);
    }

    .edge {
        position: absolute;
        background-color: black;
        height: 3px;
        transform-origin: 0 0;
    }

    button {
        margin: 10px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
    }
</style>
<body>
  <h1>Binary Tree Visualization</h1>
  <div class="container">
    <div class="tree" id="tree"></div>
  </div>
  <div>
    <button onclick="startLevelOrder()">Start Level Order Traversal</button>
    <button onclick="startPreOrder()">Start Pre-Order Traversal</button>
    <button onclick="startInOrder()">Start In-Order Traversal</button>
    <button onclick="startPostOrder()">Start Post-Order Traversal</button>
    <button onclick="resetTree()">Reset Tree</button>
  </div>
  <script>
    // TREE ILLUSTRATION
    const treeContainer = document.getElementById("tree");
    let traversalTimeouts = []; // array to store timeouts for traversal animations

    function drawNode(x, y, value) {
        const node = document.createElement("div");
        node.classList.add("node");
        node.textContent = value;
        node.style.left = `${x}px`;
        node.style.top = `${y}px`;
        treeContainer.appendChild(node);
        return node;
    }

    function drawEdge(x1, y1, x2, y2) {
        const edge = document.createElement("div");
        const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);

        edge.classList.add("edge");
        edge.style.width = `${length}px`;
        edge.style.left = `${x1}px`;
        edge.style.top = `${y1}px`;
        edge.style.transform = `rotate(${angle}deg)`;
        treeContainer.appendChild(edge);
    }

    function drawTree(arr) {
        const nodeRadius = 30; // half the new node size (60px)
        const yOffset = 140; // vertical spacing
        const horizontalSpacing = 600; // horizontal spacing
        const nodes = []; // store node references

        function helper(index, x, y, levelWidth) {
            if (index >= arr.length || arr[index] === null) return;

            // draw current node
            const currentNode = drawNode(x, y, arr[index]);
            nodes[index] = currentNode;

            // calculate positions for child nodes
            const childXOffset = levelWidth / 2;

            // draw left child and edge
            const leftIndex = 2 * index + 1;
            if (leftIndex < arr.length && arr[leftIndex] !== null) {
                const leftX = x - childXOffset;
                const leftY = y + yOffset;
                drawEdge(
                    x + nodeRadius, 
                    y + nodeRadius * 2, 
                    leftX + nodeRadius, 
                    leftY
                );
                helper(leftIndex, leftX, leftY, levelWidth / 2);
            }

            // draw right child and edge
            const rightIndex = 2 * index + 2;
            if (rightIndex < arr.length && arr[rightIndex] !== null) {
                const rightX = x + childXOffset;
                const rightY = y + yOffset;
                drawEdge(
                    x + nodeRadius, 
                    y + nodeRadius * 2, 
                    rightX + nodeRadius, 
                    rightY
                );
                helper(rightIndex, rightX, rightY, levelWidth / 2);
            }
        }

        helper(0, treeContainer.offsetWidth / 2, 40, horizontalSpacing);

        return nodes;
    }

    // EXAMPLE
    const binaryTree = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, null, null, 12, 13];
    const nodes = drawTree(binaryTree);






    // TRAVERSAL ANIMATIONS
    function highlightNodes(order) {
        resetTree(); // reset tree before starting new traversal
        traversalTimeouts = []; // clear previous timeouts
        let delay = 0;

        for (const index of order) {
            const timeout = setTimeout(() => {
                nodes[index].classList.add("visited");
            }, delay);
            traversalTimeouts.push(timeout); // store timeout ID
            delay += 500; // delay for each node
        }
    }

    function resetTree() {
        // cancel all ongoing animations
        traversalTimeouts.forEach(timeout => clearTimeout(timeout));
        traversalTimeouts = []; // clear timeout array

        // reset all nodes to white
        nodes.forEach(node => {
            if (node) node.classList.remove("visited");
        });
    }


    // level-order
    function startLevelOrder() {
        const queue = [0];
        const order = [];
        while (queue.length > 0) {
            const index = queue.shift();
            if (nodes[index]) {
                order.push(index);
                const left = 2 * index + 1;
                const right = 2 * index + 2;
                if (left < nodes.length) queue.push(left);
                if (right < nodes.length) queue.push(right);
            }
        }
        highlightNodes(order);
    }

    // pre-order
    function startPreOrder() {
        const order = [];
        function preOrder(index) {
            if (index >= nodes.length || !nodes[index]) return;
            order.push(index);
            preOrder(2 * index + 1); // Left
            preOrder(2 * index + 2); // Right
        }
        preOrder(0);
        highlightNodes(order);
    }

    // in-order
    function startInOrder() {
        const order = [];
        function inOrder(index) {
            if (index >= nodes.length || !nodes[index]) return;
            inOrder(2 * index + 1); // Left
            order.push(index);
            inOrder(2 * index + 2); // Right
        }
        inOrder(0);
        highlightNodes(order);
    }

    // post-order
    function startPostOrder() {
        const order = [];
        function postOrder(index) {
            if (index >= nodes.length || !nodes[index]) return;
            postOrder(2 * index + 1); // Left
            postOrder(2 * index + 2); // Right
            order.push(index);
        }
        postOrder(0);
        highlightNodes(order);
    }
  </script>
</body>
</html>
